Title: Coverage Prediction for Accelerating Compiler Testing

Authors: Junjie Chen, Guancheng Wang, Dan Hao, Yingfei Xiong, Hongyu Zhang, Lu Zhang, Bing Xie

Published in: IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. XX, NO. X, OCTOBER 2017

-------------x-------------x-------------x-------------

[1] What is the main problem that paper attempts to solve? (80 to 100 words)

Compiler should be well tested as it is one of the most important software system.
Researchers also involved in various techniques to accelerate the compiler bugs detection.
An important aspect in compiler testing: "Different test programs may have similar test capabilities."
That means over counting same type of bugs may mislead the evaluation result of compiler fuzzing. 
Test coverage can help but it is not feasible in dynamically because test cases are generated automatically.
To address this, authors proposed COP (COverage Prediction) technique for compilers to predict test coverage statically.
Authors also proposed the way to prioritize test cases by clustering the predicted coverage information.

[2] What is the proposed solution? (80 to 100 words)

Authors proposed COP (COverage Prediction) tecnique for compilers to predict test coverage statically. 

COP consists of three steps: 
  1) Predicting coverage for test programs:
      -> Identifying Features:
          - Define three categories of features: language features, operation features, and structure features.
          - The value of the feature is set to one if it occurs at least one time, otherwise it is set to zero.
      -> Labeling:
          - Collect the covered fraction of each compiler module as each label.
          - Each label is a real number between zero and one.
          - Note that: Removed meaningless module from the label set.
      -> Building a Prediction Model:
          - Collect a set of test programs generated by Csmith.
          - Extract features and labels of each test program.
          - Normalize features' value into the interval [0,1] using min-max normalization.
          - Build a prediction model by adopting the gradient boosting for regression.
      -> Predicting and Aligning Coverage:
          - Extract features for new test program to predict coverage.
          - Predict covered fraction of compiler module based on the learnt prediction model.
          - Note that: Removed all non-matched modules between different versions to align coverage.
  2) Clustering test programs:
      - Cluster test programs into different groups based on the predicted coverage information.
      - Use X-means clustering algorithm with Manhattan distance for clustering.
      - Test programs in different groups tend to have different test capabilities.
  3) Prioritizing test programs:
      - Use LET to get the bug-revealing probability per unit time for each test program.
      - Separate each group into two groups (high and low) based on a threshold probability.
      - First select the highest probability test program by enumerating each group.
      - Sort these selected test programs and records them into Rank.
      - Rrank test programs until all the test programs are selected.
      - Note that: Test programs having probabilities smaller than threshold are selected later.

Set two research questions:
  • RQ1: Does COP accelerate C compiler testing? 
  • RQ2: How does COP perform in terms of predicting coverage for C compilers?

Finally, conduct effectiveness evaluation of COP and compare with the state-of-the-art approach LET.

[3] How they evaluated the technique? (50 to 80 words)

Evaluate the acceleration effectiveness of COP:
  - Use two C compilers: GCC and LLVM (old + 12 latest release versions).
  - Compare with the state-of-the-art approach LET.

Experimental results of COP:
  - Accelerate compiler testing in 93.97% cases in test execution time.
  - Achieve an average of 51.01% speedup on the existing constructed dataset.
  - Achieve an average of 68.74% speedup on the dataset of latest release versions.
  - Accelerate compiler testing (more than 92.86%) in almost all cases, techniques and application scenarios.
  - Accelerate compiler testing (speedup: 46.12% to 55.78%) for both DOL and EMI on same-version and cross-version scenarios.
  
Compare COP with LET:
  - LET decelerates compiler testing 14 times  while only 7 times by COP.
  - The mean improvements of COP over LET are ranging 14.26% to 55.27%.
  - COP outperforms LET by improving 17.16% ∼82.51% speedups in different settings on average.
  - For some cases, COP performs worse than LET because of unrelated features and higher setup time which delays the bug detection speedup.
  
Acceleration Effectiveness on Latest Release Versions:
  - COP accelerates the testing of the latest release versions in 84.21% cases.
  - The mean speedup of COP is 68.74% outperforming the mean speedup 51.01% on old versions.
  - COP performs better than LET in 73.68% cases on the latest release versions.
  - The mean improvement of COP over LET is 49.18%.
 
Acceleration Effectiveness on Swarm Testing:
  - COP almost accelerates the compiler testing in 82.35%.
  - The average speedup of COP is 38.37% compared with swarm testing.
  - The average speedup of COP is 14.88% compared with LET based on swarm testing.
  
Prediction Effectiveness:
  - The MAE values in the cross-version application scenario are larger than the same-version application scenario.
  - The MAE values of COP are extremely small (0.034∼0.051), demonstrating its high accuracy on predicting coverage in the same-version application scenario. 
  - The EV and R2 values in the cross-version application scenario are smaller than the same-version application scenario.
  - Both EV and R2 of COP are large, demonstrating its high predictability of coverage in the same-version application scenario.
  
Accuracy of COP on predicting coverage:
  - Achieve 0.034∼0.051 mean absolute errors when predicting coverage within the same version.
  - Achieve 0.052∼0.116 mean absolute errors when predicting coverage across the versions.
   
[4] How was it related to your research? (10 to 20 words)

This paper guides static coverage predection, that will help to ignore redundant type of programs and will accelerate the fuzzing.
